# Singleton (creational pattern)

Singleton is a creational design pattern that allows us to ensure that a class has a single instance, while providing a global access point to that instance. It is useful when an object is very heavy to create or requires a lot of computational resources to create.

![Singleton Image](./assets/Singleton.png)

More info: [Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern)

# Strategy (behavioral pattern)

The strategy pattern allows you to maintain a set of algorithms from which the client object can choose the one that suits it best and dynamically swap it according to its needs.

It helps to extend behaviors without modifying other existing behaviors. It is useful for new changes in requirements or functionalities in systems.

![](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/Strategy.png)

More info: [Strategy (patrón de diseño) - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Strategy_(patr%C3%B3n_de_dise%C3%B1o))

# Decorator (structural pattern)

In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other instances of the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern as well as to the Open-Closed Principle, by allowing the functionality of a class to be extended without being modified. Decorator use can be more efficient than subclassing, because an object's behavior can be augmented without defining an entirely new object.

![Decorator](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/Decorator.png)

More info: [Decorator pattern - Wikipedia](https://en.wikipedia.org/wiki/Decorator_pattern)

# Observer (behavioral pattern)

Observer Design Pattern is a behavioral pattern that establishes a one-to-many dependency between objects. When the subject changes its state, all its observers are automatically notified and updated. It focuses on enabling efficient communication and synchronization between objects in response to state changes.

![](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/Observer.png)

More info: [Observer Design Pattern - GeeksforGeeks](https://www.geeksforgeeks.org/system-design/observer-pattern-set-1-introduction/)

# Dependency injection (Software design pattern)

Dependency injection is a programming technique that makes a class independent of its dependencies. It achieves that by decoupling the usage of an object from its creation. This helps you to follow SOLID’s dependency inversion and single responsibility principles.

![](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/Dependency_Injection.png)

More info: [Design Patterns Explained – Dependency Injection- Stackify](https://stackify.com/dependency-injection/)

# Factory Method (creational pattern)

This pattern allows you to create objects without specifying the object type.

![](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/Factory%20Method.png)

More info: [Factory method pattern - Wikipedia](https://en.wikipedia.org/wiki/Factory_method_pattern)

# State (behavioral pattern)

An object has a state. Depending on its state, it will have different behaviors. This behavior can change at runtime. Protects from unexpected behavior.

![](/home/gabyolmos/Escritorio/Curso%20de%20Patrones%20de%20Diseño%20en%20Python/assets/State.png)

More info: [State Design Pattern - GeeksforGeeks](https://www.geeksforgeeks.org/system-design/state-design-pattern/) and [State](https://refactoring.guru/design-patterns/state)



To be continued...
